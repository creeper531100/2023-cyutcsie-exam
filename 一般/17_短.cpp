#include <iostream>
#include <algorithm>
#include <fstream>

/*
 * 需要注意的是，程式碼中的 std::sort 函式需要使用 algorithm 標頭檔案。
 * 因此使用sort需要在檔案開頭加上 "#include<algorithm>" 才能順利編譯。
 */

using namespace std;
int main() {
    int data[99] = { 0 }; // 儲存輸入的正整數序列
    int len = 0; // 正整數序列的長度

    ifstream ifs("123.txt"); // 讀取輸入檔案

    // 讀入正整數序列
    while (ifs >> data[len]) {
        printf("%d ", data[len]); // 輸出每個輸入的數字
        len++; // 更新正整數序列的長度
    }

    // 從序列中取得K值
    int K = data[len - 1];
    printf("\n%d\nAns=", K);

    for (int i = 0; i <= len - K - 1; i++) {
        int window[10] = { 0 };

        // 從data陣列中 從i複製長度K至window
        memcpy(window, data + i, K * sizeof(int));

        //排序
        sort(window, window + K);

        cout << window[K / 2] << " ";
    }
}

/*
 * 中值濾波演算法常用於影像處理，底下使用一串資料來說明演算法的運作：
 * 假設輸入一串正整數如下：
 * 5 16 9 20 3 14 6 8 9 18 32 2
 * 濾波器需要設定一個視窗大小，K(奇數: 3, 5, …)，假設 K=3，將該串數字從左到右，
 * 每 3 個數字排序後，輸出排在中間的數值，針對上面的例子，輸出結果如下：
 * 5  字串一開始，個數不足 3 個不處理濾波動作
 * 5 16  字串一開始，個數不足 3 個不處理濾波動作
 * 5 16 9  排序後 5 9 16，所以輸出 9
 * 16 9 20 排序後 9 16 20，所以輸出 16
 * 9 20 3  排序後 3 9 20，所以輸出 9
 * …
 * 上面正整數的輸出結果為：
 * 9 16 9 14 6 8 8 9 18 18
 * 所以，數字中幾個特別大或小的數字就被過濾掉了，如：3 20 32 2
 * 請從資料檔 e.txt 中第一行讀入一串正整數，個數 N(最多 100 個)，以及第二行讀入
 * 一個 K 值(奇數 K>=3, K<=N)，接著輸出濾波結果。
 * 範例輸入：
 * 5 16 9 20 3 14 6 8 9 18 32 2
 * 3
 * 範例輸出：
 * 5 16 9 20 3 14 6 8 9 18 32 2
 * 3
 * Ans=9 16 9 14 6 8 8 9 18 18
 */

#include <fstream>
#include <iostream>
#include <sstream>
using namespace std;

int main() {
    string res;
    ifstream ifs("123.txt");

    ifs >> res;

    stringstream ss(res); // 創建一個字串流對象，將 res 字串輸入其中
    string sub; // 用於存放從字串流中分割出的子字串

    cout << res << "\nAns=";

    // 以 'C' 字元作為分隔符，從字串流中逐行讀取子字串
    // 並進行後續處理
    getline(ss, sub, 'C');

    // 循環處理每一個子字串
    while (getline(ss, sub, 'C')) {
        // 獲取每個子字串的第一個字符轉換為偏移
        int offset = sub[0] - '0'; 

        // 遍歷子字串的每個字符，進行偏移計算
        for (int i = 1; i < sub.length(); i++) {
            // 計算數字的偏移，並將其轉換為非負數（使用10來進行循環）
            // 如果偏移後是負數，則加上 10 保證結果是非負的
            int ans = ((sub[i] - '0') - offset + 10) % 10;
            cout << ans; // 輸出計算結果
        }
    }

    cout << endl;
}

/*
 * 小明想要安全的將一串由數字 0~9 所構成的字串傳給朋友，於是他想了一個方法，他把
 * 這個字串切成好幾段不固定長度的子字串，每一段都隨機使用一個位移編碼的方式來進
 * 行傳換，位移量為 1~9，並且每一段子字串的開頭加入一個字元‘C’，這樣朋友收到之
 * 後，就可以依照指定方式來還原出原始字串。底下是一個例子，假設原始字串如下：
 * 042332300077139487945
 * 小明將上面字串隨機切割為好幾個子字串如下：
 * 04 23323000 771394 87945
 * 每一段使用不同的隨機位移量進行編碼：
 * 04 (位移量 3)  37
 * 23323000 (位移量 8)  01101888
 * 771394 (位移量 2)  993516
 * 87945 (位移量 7)  54612
 * 所以真正傳送給朋友的字串如下：
 * C337C801101888C2993516C754612
 * 麻煩從資料檔 d.txt 中讀入這一段編碼的字串，然後解碼還原出原本小明想要傳送的字
 * 串。
 * 範例輸入：
 * C337C801101888C2993516C754612
 * 範例輸出：
 * C337C801101888C2993516C754612
 * Ans=042332300077139487945
 */
